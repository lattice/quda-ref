<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QUDA: lib/dslash_index.cuh File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QUDA
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dslash_index.cuh File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="dslash__index_8cuh_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2bfb0a0ff1c379a8b4e8f9d24fdd4839"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a> { <a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a2ff0d46003d17afdfe71d2a800cebf19">EVEN_X</a> = 0, 
<a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a458836ffb18d20f9c43db0410726cd73">EVEN_Y</a> = 1, 
<a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a8059c79a99673da643e3b83a4656e8b7">EVEN_Z</a> = 2, 
<a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839aa97f05d3ad6c15d9eadc32594f3ead76">EVEN_T</a> = 3
 }</td></tr>
<tr class="separator:a2bfb0a0ff1c379a8b4e8f9d24fdd4839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4af1608b0016c61283b08bf7abb2e6c"><td class="memTemplParams" colspan="2">template&lt;int dim, int nLayers, int face_num, typename Param &gt; </td></tr>
<tr class="memitem:aa4af1608b0016c61283b08bf7abb2e6c"><td class="memTemplItemLeft" align="right" valign="top">static __device__ int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#aa4af1608b0016c61283b08bf7abb2e6c">indexFromFaceIndexExtended</a> (int face_idx, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:aa4af1608b0016c61283b08bf7abb2e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global extended checkerboard index from face index. The following indexing routines work for arbitrary (including odd) lattice dimensions. Specifically, we compute an index into the local volume from an index into the face. This is used by the Wilson-like face packing routines.  <a href="#aa4af1608b0016c61283b08bf7abb2e6c">More...</a><br /></td></tr>
<tr class="separator:aa4af1608b0016c61283b08bf7abb2e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dc63be6f290a69d58c128bbf371213"><td class="memTemplParams" colspan="2">template&lt;int dim, int nLayers, int face_num, typename Param &gt; </td></tr>
<tr class="memitem:a72dc63be6f290a69d58c128bbf371213"><td class="memTemplItemLeft" align="right" valign="top">static __device__ int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a72dc63be6f290a69d58c128bbf371213">indexFromFaceIndexStaggered</a> (int face_idx_in, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:a72dc63be6f290a69d58c128bbf371213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global checkerboard index from face index. The following indexing routines work for arbitrary lattice dimensions (though perhaps not odd like thw Wilson variant?) Specifically, we compute an index into the local volume from an index into the face. This is used by the staggered-like face packing routines, and is different from the Wilson variant since here the halo depth is tranversed in a different order - here the halo depth is the faster running dimension.  <a href="#a72dc63be6f290a69d58c128bbf371213">More...</a><br /></td></tr>
<tr class="separator:a72dc63be6f290a69d58c128bbf371213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c56c9bab3c44280a091e907bbf13fc6"><td class="memTemplParams" colspan="2">template&lt;int dim, int nLayers, int face_num, typename Param &gt; </td></tr>
<tr class="memitem:a4c56c9bab3c44280a091e907bbf13fc6"><td class="memTemplItemLeft" align="right" valign="top">static __device__ int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a4c56c9bab3c44280a091e907bbf13fc6">indexFromFaceIndexExtendedStaggered</a> (int face_idx, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:a4c56c9bab3c44280a091e907bbf13fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global extended checkerboard index from face index. The following indexing routines work for arbitrary lattice dimensions (though perhaps not odd like thw Wilson variant?) Specifically, we compute an index into the local volume from an index into the face. This is used by the staggered-like face packing routines, and is different from the Wilson variant since here the halo depth is tranversed in a different order - here the halo depth is the faster running dimension.  <a href="#a4c56c9bab3c44280a091e907bbf13fc6">More...</a><br /></td></tr>
<tr class="separator:a4c56c9bab3c44280a091e907bbf13fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de9b03ab7749d1660338f81de00940"><td class="memTemplParams" colspan="2">template&lt;KernelType dim, int nLayers, int Dir, typename Param &gt; </td></tr>
<tr class="memitem:af9de9b03ab7749d1660338f81de00940"><td class="memTemplItemLeft" align="right" valign="top">static __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#af9de9b03ab7749d1660338f81de00940">coordsFromFaceIndexStaggered</a> (int x[], int idx, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:af9de9b03ab7749d1660338f81de00940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the full-lattice coordinates from the input face index. This is used by the staggered halo update kernels.  <a href="#af9de9b03ab7749d1660338f81de00940">More...</a><br /></td></tr>
<tr class="separator:af9de9b03ab7749d1660338f81de00940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376eb577f79c2a0473ede28dd1668d9c"><td class="memTemplParams" colspan="2">template&lt;int nDim, QudaPCType pc_type, IndexType idxType, typename T , typename Param &gt; </td></tr>
<tr class="memitem:a376eb577f79c2a0473ede28dd1668d9c"><td class="memTemplItemLeft" align="right" valign="top">static __device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a376eb577f79c2a0473ede28dd1668d9c">coordsFromIndex</a> (int &amp;idx, T *x, int &amp;cb_idx, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:a376eb577f79c2a0473ede28dd1668d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute coordinates from index into the checkerboard (used by the interior Dslash kernels). This is used by the Wilson-like interior update kernels, and can deal with 4-d or 5-d field and 4-d or 5-d preconditioning.  <a href="#a376eb577f79c2a0473ede28dd1668d9c">More...</a><br /></td></tr>
<tr class="separator:a376eb577f79c2a0473ede28dd1668d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22145d6cbaa8bfbe6da6de3166530116"><td class="memTemplParams" colspan="2">template&lt;IndexType idxType, typename Int , typename Param &gt; </td></tr>
<tr class="memitem:a22145d6cbaa8bfbe6da6de3166530116"><td class="memTemplItemLeft" align="right" valign="top">static __device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a22145d6cbaa8bfbe6da6de3166530116">coordsFromIndex3D</a> (int &amp;idx, Int *const x, int &amp;cb_idx, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:a22145d6cbaa8bfbe6da6de3166530116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute coordinates from index into the checkerboard (used by the interior Dslash kernels). This is the variant used by the shared memory wilson dslash.  <a href="#a22145d6cbaa8bfbe6da6de3166530116">More...</a><br /></td></tr>
<tr class="separator:a22145d6cbaa8bfbe6da6de3166530116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3723508c097593d6b0c8649c70104951"><td class="memTemplParams" colspan="2">template&lt;int dim, typename T &gt; </td></tr>
<tr class="memitem:a3723508c097593d6b0c8649c70104951"><td class="memTemplItemLeft" align="right" valign="top">static __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#a3723508c097593d6b0c8649c70104951">inBoundary</a> (const int depth, const int coord[], const T <a class="el" href="staggered__invert__test_8cpp.html#a7facd8f2fefe0ccaea751dff2592badb">X</a>[])</td></tr>
<tr class="memdesc:a3723508c097593d6b0c8649c70104951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the provided coordinate is within the halo region boundary of a given dimension.  <a href="#a3723508c097593d6b0c8649c70104951">More...</a><br /></td></tr>
<tr class="separator:a3723508c097593d6b0c8649c70104951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b92fbb0dda15351bf7fc9b2beb6722"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7b92fbb0dda15351bf7fc9b2beb6722"><td class="memTemplItemLeft" align="right" valign="top">static __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#af7b92fbb0dda15351bf7fc9b2beb6722">isActive</a> (const int threadDim, int offsetDim, int offset, const int y[], const int partitioned[], const T <a class="el" href="staggered__invert__test_8cpp.html#a7facd8f2fefe0ccaea751dff2592badb">X</a>[])</td></tr>
<tr class="memdesc:af7b92fbb0dda15351bf7fc9b2beb6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether this thread should be active for updating the a given offsetDim halo. This is used by the fused halo region update kernels: here every thread has a prescribed dimension it is tasked with updating, but for the edges and vertices, the thread responsible for the entire update is the "greatest" one. Hence some threads may be labelled as a given dimension, but they have to update other dimensions too. Conversely, a given thread may be labeled for a given dimension, but if that thread lies at en edge or vertex, and we have partitioned a higher dimension, then that thread will cede to the higher thread.  <a href="#af7b92fbb0dda15351bf7fc9b2beb6722">More...</a><br /></td></tr>
<tr class="separator:af7b92fbb0dda15351bf7fc9b2beb6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab83429b3b977339184d169cf050825d"><td class="memTemplParams" colspan="2">template&lt;int nDim, int nLayers, typename I , typename Param &gt; </td></tr>
<tr class="memitem:aab83429b3b977339184d169cf050825d"><td class="memTemplItemLeft" align="right" valign="top">static __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#aab83429b3b977339184d169cf050825d">faceIndexFromCoords</a> (int &amp;face_idx, I *const x, int face_dim, const Param &amp;<a class="el" href="pack__test_8cpp.html#aba126262dff054e28bac5c0d901769c8">param</a>)</td></tr>
<tr class="memdesc:aab83429b3b977339184d169cf050825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the face index from the lattice coordinates.  <a href="#aab83429b3b977339184d169cf050825d">More...</a><br /></td></tr>
<tr class="separator:aab83429b3b977339184d169cf050825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd13e4956b7f1fc426ae6239fe80a4f8"><td class="memItemLeft" align="right" valign="top">__device__ float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dslash__index_8cuh.html#acd13e4956b7f1fc426ae6239fe80a4f8">__fast_pow</a> (float a, int b)</td></tr>
<tr class="separator:acd13e4956b7f1fc426ae6239fe80a4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2bfb0a0ff1c379a8b4e8f9d24fdd4839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dslash__index_8cuh.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2bfb0a0ff1c379a8b4e8f9d24fdd4839a2ff0d46003d17afdfe71d2a800cebf19"></a>EVEN_X&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2bfb0a0ff1c379a8b4e8f9d24fdd4839a458836ffb18d20f9c43db0410726cd73"></a>EVEN_Y&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2bfb0a0ff1c379a8b4e8f9d24fdd4839a8059c79a99673da643e3b83a4656e8b7"></a>EVEN_Z&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2bfb0a0ff1c379a8b4e8f9d24fdd4839aa97f05d3ad6c15d9eadc32594f3ead76"></a>EVEN_T&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00332">332</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd13e4956b7f1fc426ae6239fe80a4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd13e4956b7f1fc426ae6239fe80a4f8">&#9670;&nbsp;</a></span>__fast_pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ float __fast_pow </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00626">626</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

</div>
</div>
<a id="af9de9b03ab7749d1660338f81de00940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9de9b03ab7749d1660338f81de00940">&#9670;&nbsp;</a></span>coordsFromFaceIndexStaggered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;KernelType dim, int nLayers, int Dir, typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ void coordsFromFaceIndexStaggered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the full-lattice coordinates from the input face index. This is used by the staggered halo update kernels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x[out]</td><td>Coordinates we are computing </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx[in]</td><td>Input checkerboard face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00265">265</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="index__helper_8cuh_source.html#l00470">quda::EXTERIOR_KERNEL_T</a>, <a class="el" href="index__helper_8cuh_source.html#l00467">quda::EXTERIOR_KERNEL_X</a>, <a class="el" href="index__helper_8cuh_source.html#l00468">quda::EXTERIOR_KERNEL_Y</a>, <a class="el" href="index__helper_8cuh_source.html#l00469">quda::EXTERIOR_KERNEL_Z</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

</div>
</div>
<a id="a376eb577f79c2a0473ede28dd1668d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376eb577f79c2a0473ede28dd1668d9c">&#9670;&nbsp;</a></span>coordsFromIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nDim, QudaPCType pc_type, IndexType idxType, typename T , typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void coordsFromIndex </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>cb_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute coordinates from index into the checkerboard (used by the interior Dslash kernels). This is used by the Wilson-like interior update kernels, and can deal with 4-d or 5-d field and 4-d or 5-d preconditioning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">idx[out]</td><td>The full lattice coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cb_idx[out]</td><td>The checkboarded lattice coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x[out]</td><td>Coordinates we are computing </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx[in]</td><td>Input checkerboarded face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>
<p>(X[0] &amp; 1)</p>
<p>(X[1] &amp; 1)</p>
<p>(X[2] &amp; 1) </p>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00352">352</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="dslash__index_8cuh_source.html#l00333">EVEN_X</a>, <a class="el" href="dslash__index_8cuh_source.html#l00334">EVEN_Y</a>, <a class="el" href="dslash__index_8cuh_source.html#l00335">EVEN_Z</a>, <a class="el" href="enum__quda_8h_source.html#l00396">QUDA_4D_PC</a>, <a class="el" href="namespacequda.html#a011e515b863de3a8e2621be203bb1682">quda::s</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="shift__quark__field_8cu_source.html#l00041">quda::neighborIndex()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="dslash__index_8cuh_a376eb577f79c2a0473ede28dd1668d9c_icgraph.png" border="0" usemap="#dslash__index_8cuh_a376eb577f79c2a0473ede28dd1668d9c_icgraph" alt=""/></div>
<map name="dslash__index_8cuh_a376eb577f79c2a0473ede28dd1668d9c_icgraph" id="dslash__index_8cuh_a376eb577f79c2a0473ede28dd1668d9c_icgraph">
<area shape="rect" id="node2" href="namespacequda.html#a8daab04d5390104160d3b7d88fa99a91" title="quda::neighborIndex" alt="" coords="175,436,311,463"/>
<area shape="rect" id="node3" href="namespacequda.html#ac413ca7f18a060fb34bb7437d5a0cdc4" title="quda::shiftColorSpinorField\lKernel" alt="" coords="359,370,533,411"/>
<area shape="rect" id="node4" href="dslash__util_8h.html#a54eefa6f808a5ffc4304d0ad12e23c5f" title="gaugeLink" alt="" coords="405,436,487,463"/>
<area shape="rect" id="node33" href="dslash__util_8h.html#a936166ad1ee9ba501afa662c0e044558" title="spinorNeighbor" alt="" coords="393,487,499,513"/>
<area shape="rect" id="node5" href="covdev__reference_8cpp.html#a153edc62c58b2a4cd352e4298fa939d7" title="covdevReference" alt="" coords="581,461,703,488"/>
<area shape="rect" id="node30" href="staggered__dslash__reference_8cpp.html#a74c575aa20c8f163c5f9bfe2e4431ea3" title="dslashReference" alt="" coords="583,385,701,412"/>
<area shape="rect" id="node6" href="covdev__reference_8h.html#aab04171420a0617681f38c9811faa347" title="covdev_dslash" alt="" coords="751,512,856,539"/>
<area shape="rect" id="node7" href="covdev__reference_8cpp.html#a510195acd5d3e923bcae7f70d39a0b11" title="Mat" alt="" coords="781,461,825,488"/>
<area shape="rect" id="node26" href="covdev__reference_8cpp.html#a8698d271fa81fce7f2cdd9d01f5bd37e" title="Matdagmat" alt="" coords="760,259,847,285"/>
<area shape="rect" id="node8" href="namespacequda.html#a8a3d36aa906fc8cf6984a8f951a67095" title="quda::cloverInvertCompute" alt="" coords="904,512,1079,539"/>
<area shape="rect" id="node9" href="namespacequda.html#aa987cec88bf5e971204dfe852f169dbe" title="quda::ComputeTMAVGPU" alt="" coords="905,563,1077,589"/>
<area shape="rect" id="node10" href="namespacequda.html#a991eb0331f3bc1e606d590e7daa72aee" title="Apply the preconditioned twisted&#45;clover dslash. " alt="" coords="925,613,1057,640"/>
<area shape="rect" id="node11" href="namespacequda.html#a6dee5a13d3c20e5499dc454b004c20d1" title="quda::getTrace" alt="" coords="938,259,1045,285"/>
<area shape="rect" id="node16" href="namespacequda.html#aa2770ef66427e1e0861d7685d363907a" title="quda::getDeterminant" alt="" coords="919,664,1063,691"/>
<area shape="rect" id="node17" href="namespacequda.html#a8ce4314c844c230d4bd9b2bb0b7cfdfa" title="quda::operator+=" alt="" coords="932,715,1051,741"/>
<area shape="rect" id="node18" href="namespacequda.html#abbe6dad1180560e1d62ffcc4231f0d44" title="quda::operator*" alt="" coords="937,765,1045,792"/>
<area shape="rect" id="node19" href="namespacequda.html#aae0df96f85eda0c72f93ca6398fad2db" title="quda::operator*=" alt="" coords="933,816,1049,843"/>
<area shape="rect" id="node20" href="blas__magma_8cu.html#a83177cddacc20617163e82b33b49f89d" title="magma_Xgesv" alt="" coords="938,157,1045,184"/>
<area shape="rect" id="node21" href="blas__magma_8cu.html#ac65c95f58fc45bfd95869a0a46610df0" title="magma_Xgeev" alt="" coords="937,208,1045,235"/>
<area shape="rect" id="node22" href="blas__magma_8cu.html#a4c2682b088feef2f297278a95dcbe6a7" title="magma_Xgels" alt="" coords="939,309,1043,336"/>
<area shape="rect" id="node23" href="blas__magma_8cu.html#aea89e41651e9e05f3af08a4c9062a842" title="magma_Xheev" alt="" coords="937,360,1045,387"/>
<area shape="rect" id="node24" href="namespacequda.html#ad0da1353efb2b6174454d8416e3be158" title="quda::twistCloverApply" alt="" coords="916,411,1067,437"/>
<area shape="rect" id="node25" href="covdev__reference_8h.html#a8678fbff3ed31d6f486ab33232e2d005" title="mat" alt="" coords="969,461,1013,488"/>
<area shape="rect" id="node12" href="namespacequda.html#a2510f4db6080796d8778edac3f7f22d2" title="quda::plaquette" alt="" coords="1181,233,1291,260"/>
<area shape="rect" id="node13" href="namespacequda.html#a3af3c043803491aaea5c22d9c7807115" title="quda::qChargeComputeKernel" alt="" coords="1139,284,1333,311"/>
<area shape="rect" id="node14" href="namespacequda.html#a4c6454379fb7e715088552d1f2340f9c" title="quda::computeSTOUTStep" alt="" coords="1147,335,1325,361"/>
<area shape="rect" id="node15" href="namespacequda.html#abb828db4d01a4a845f7448943e02d120" title="quda::computeOvrImpSTOUTStep" alt="" coords="1127,183,1345,209"/>
<area shape="rect" id="node27" href="covdev__reference_8h.html#a889c78c66d143bdfb3ade7271407a422" title="matdagmat" alt="" coords="948,107,1035,133"/>
<area shape="rect" id="node28" href="staggered__dslash__ctest_8cpp.html#a395582865fa2cf85dfdc964a961ac000" title="staggeredDslashRef" alt="" coords="1168,107,1304,133"/>
<area shape="rect" id="node29" href="staggered__invert__test_8cpp.html#a73b12a1c950a0324fc1d9f45d7153a73" title="invert_test" alt="" coords="1195,56,1277,83"/>
<area shape="rect" id="node31" href="staggered__dslash__reference_8h.html#a644fdeeba8af318dc56a43af6791d46f" title="staggered_dslash" alt="" coords="931,56,1052,83"/>
<area shape="rect" id="node32" href="staggered__dslash__reference_8h.html#a4c8ec3cadcd9089eb793c2d8bbb57045" title="matdagmat" alt="" coords="1193,5,1279,32"/>
<area shape="rect" id="node34" href="wilson__dslash__reference_8cpp.html#a254701a68d337537a66c9cf0c8f67f24" title="dslashReference" alt="" coords="583,841,701,868"/>
<area shape="rect" id="node35" href="wilson__dslash__reference_8h.html#a4baf1106373856ef3ddf22ded94da45a" title="wil_dslash" alt="" coords="763,1196,843,1223"/>
<area shape="rect" id="node36" href="wilson__dslash__reference_8h.html#ae07c1a8764ffd56ab4823ffb2d9b275c" title="clover_dslash" alt="" coords="942,1221,1041,1248"/>
<area shape="rect" id="node37" href="dslash__ctest_8cpp.html#a67d49cd517919ae845535dcd9e7585c7" title="dslashRef" alt="" coords="1197,1221,1275,1248"/>
<area shape="rect" id="node38" href="wilson__dslash__reference_8h.html#aa44d6283bd416112a1b8b041504c413d" title="clover_matpc" alt="" coords="942,1272,1041,1299"/>
<area shape="rect" id="node39" href="wilson__dslash__reference_8h.html#a69e3f1607c121be48fc540b0b4fd43a3" title="clover_mat" alt="" coords="949,1323,1034,1349"/>
<area shape="rect" id="node40" href="wilson__dslash__reference_8h.html#a4fa28c6e8f2141fc1838ea8582756807" title="tmc_dslash" alt="" coords="948,1373,1035,1400"/>
<area shape="rect" id="node41" href="wilson__dslash__reference_8h.html#a9ec587006fc538ff89d33e0d9ea6c5fd" title="tmc_mat" alt="" coords="955,1424,1028,1451"/>
<area shape="rect" id="node42" href="wilson__dslash__reference_8h.html#af47d4a96b1e9667333ae7973e3c8cc0f" title="tmc_matpc" alt="" coords="948,1475,1035,1501"/>
<area shape="rect" id="node43" href="wilson__dslash__reference_8h.html#aa6b1bacabd159ad43da2ffb55d925291" title="tm_dslash" alt="" coords="951,1525,1031,1552"/>
<area shape="rect" id="node44" href="wilson__dslash__reference_8h.html#a6a98beaba10187acbfb57a9062307421" title="wil_mat" alt="" coords="958,1576,1025,1603"/>
<area shape="rect" id="node45" href="wilson__dslash__reference_8h.html#a24a1dd19145f9b9f787285a06ecf3710" title="tm_mat" alt="" coords="958,867,1025,893"/>
<area shape="rect" id="node46" href="wilson__dslash__reference_8h.html#a005841d28a38973b18c6e00549719a0d" title="wil_matpc" alt="" coords="951,917,1031,944"/>
<area shape="rect" id="node47" href="wilson__dslash__reference_8h.html#a4e871b0ffa516458fc080ff3188a5a96" title="tm_matpc" alt="" coords="951,968,1031,995"/>
<area shape="rect" id="node48" href="wilson__dslash__reference_8h.html#aa21c9574de771dbefa8bed2d678748fd" title="tm_ndeg_dslash" alt="" coords="934,1019,1049,1045"/>
<area shape="rect" id="node49" href="wilson__dslash__reference_8h.html#ace75b4c5ca7e210ca873e627a272a82b" title="tm_ndeg_matpc" alt="" coords="934,1069,1049,1096"/>
<area shape="rect" id="node50" href="wilson__dslash__reference_8h.html#ab3abff9d87e1bdf25aa494a2582827df" title="tm_ndeg_mat" alt="" coords="941,1120,1042,1147"/>
</map>
</div>

</div>
</div>
<a id="a22145d6cbaa8bfbe6da6de3166530116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22145d6cbaa8bfbe6da6de3166530116">&#9670;&nbsp;</a></span>coordsFromIndex3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IndexType idxType, typename Int , typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void coordsFromIndex3D </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int *const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>cb_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute coordinates from index into the checkerboard (used by the interior Dslash kernels). This is the variant used by the shared memory wilson dslash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">idx</td><td>Linear index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>Compute coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ch_idx</td><td>Linear checkboard index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00499">499</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="dslash__index_8cuh_source.html#l00333">EVEN_X</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

</div>
</div>
<a id="aab83429b3b977339184d169cf050825d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab83429b3b977339184d169cf050825d">&#9670;&nbsp;</a></span>faceIndexFromCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nDim, int nLayers, typename I , typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ void faceIndexFromCoords </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>face_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I *const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the face index from the lattice coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_idx</td><td>Face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Lattice coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_dim</td><td>Which dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Input parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dimension this face_idx corresponds to </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00606">606</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

</div>
</div>
<a id="a3723508c097593d6b0c8649c70104951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3723508c097593d6b0c8649c70104951">&#9670;&nbsp;</a></span>inBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ bool inBoundary </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>coord</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>X</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether the provided coordinate is within the halo region boundary of a given dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of halo </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>Lattice dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if in boundary, else false </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00529">529</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

</div>
</div>
<a id="aa4af1608b0016c61283b08bf7abb2e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4af1608b0016c61283b08bf7abb2e6c">&#9670;&nbsp;</a></span>indexFromFaceIndexExtended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int nLayers, int face_num, typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ int indexFromFaceIndexExtended </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute global extended checkerboard index from face index. The following indexing routines work for arbitrary (including odd) lattice dimensions. Specifically, we compute an index into the local volume from an index into the face. This is used by the Wilson-like face packing routines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_idx</td><td>Checkerboarded face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global extended checkerboard coordinate </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00013">13</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="interface__quda_8cpp_source.html#l00084">R</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

</div>
</div>
<a id="a4c56c9bab3c44280a091e907bbf13fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c56c9bab3c44280a091e907bbf13fc6">&#9670;&nbsp;</a></span>indexFromFaceIndexExtendedStaggered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int nLayers, int face_num, typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ int indexFromFaceIndexExtendedStaggered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute global extended checkerboard index from face index. The following indexing routines work for arbitrary lattice dimensions (though perhaps not odd like thw Wilson variant?) Specifically, we compute an index into the local volume from an index into the face. This is used by the staggered-like face packing routines, and is different from the Wilson variant since here the halo depth is tranversed in a different order - here the halo depth is the faster running dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_idx_in</td><td>Checkerboarded face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global extended checkerboard coordinate </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00179">179</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="face__gauge_8cpp_source.html#l00041">dims</a>, <a class="el" href="interface__quda_8cpp_source.html#l00084">R</a>, <a class="el" href="test__util_8cpp_source.html#l00027">V</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

</div>
</div>
<a id="a72dc63be6f290a69d58c128bbf371213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dc63be6f290a69d58c128bbf371213">&#9670;&nbsp;</a></span>indexFromFaceIndexStaggered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int nLayers, int face_num, typename Param &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ int indexFromFaceIndexStaggered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_idx_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Param &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute global checkerboard index from face index. The following indexing routines work for arbitrary lattice dimensions (though perhaps not odd like thw Wilson variant?) Specifically, we compute an index into the local volume from an index into the face. This is used by the staggered-like face packing routines, and is different from the Wilson variant since here the halo depth is tranversed in a different order - here the halo depth is the faster running dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_idx_in</td><td>Checkerboarded face index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter struct with required meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global checkerboard coordinate </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00110">110</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

<p class="reference">References <a class="el" href="face__gauge_8cpp_source.html#l00041">dims</a>, <a class="el" href="namespacequda.html#a011e515b863de3a8e2621be203bb1682">quda::s</a>, and <a class="el" href="covdev__test_8cpp_source.html#l00070">X</a>.</p>

</div>
</div>
<a id="af7b92fbb0dda15351bf7fc9b2beb6722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b92fbb0dda15351bf7fc9b2beb6722">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ bool isActive </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>threadDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>partitioned</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>X</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether this thread should be active for updating the a given offsetDim halo. This is used by the fused halo region update kernels: here every thread has a prescribed dimension it is tasked with updating, but for the edges and vertices, the thread responsible for the entire update is the "greatest" one. Hence some threads may be labelled as a given dimension, but they have to update other dimensions too. Conversely, a given thread may be labeled for a given dimension, but if that thread lies at en edge or vertex, and we have partitioned a higher dimension, then that thread will cede to the higher thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadDim</td><td>Prescribed dimension of this thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsetDim</td><td>The dimension we are querying whether this thread should be responsible </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The size of the hop </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Site coordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioned</td><td>Array of which dimensions have been partitioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>Lattice dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this thread is active </dd></dl>

<p class="definition">Definition at line <a class="el" href="dslash__index_8cuh_source.html#l00555">555</a> of file <a class="el" href="dslash__index_8cuh_source.html">dslash_index.cuh</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
